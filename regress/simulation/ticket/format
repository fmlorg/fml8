#!/usr/local/bin/perl
#
# $Id$
#

use strict;
use Carp;
use vars qw(%article %options %cost %costed_ticket);
use Getopt::Long;
use lib qw(./fml/lib ./cpan/lib);
use Jcode;
use MIME::Base64;

GetOptions(\%options, qw(debug! -D=s));

my $ml_home_dir = $options{ D } || croak("-D directory");

my ($buf);
my ($date, $age, $status, $ticket_id, @articles);
while (<>) {
    if (/^\d+/) {
	($date, $age, $status, $ticket_id, @articles) = split;
	my $cost                = $status.'-'.$age;
	$cost{ $cost }          = $_;
	$costed_ticket{ $cost } = $ticket_id;
	$article{ $ticket_id }  = $articles[0];
    }
    else {
	$buf .= $_;
    }
}

if (%article) {
    print $buf;
    ShowList( \%cost );
    print "   ---------------------\n";
    print "\n";
    ShowSummary( \%article );
}

exit 0;


sub ShowList
{
    my ($cost) = @_;
    my $k;

    for $k (sort { $b cmp $a } keys %$cost) {
	print $cost{ $k };
    }
}


sub ShowSummary
{
    my ($article) = @_;
    my ($cost, $tid, $num);
    my $f;

    print "\"!\" mark: stalled? please check and reply it!!!\n";

    for $cost (sort { $b cmp $a } keys %costed_ticket) {
	$tid = $costed_ticket{ $cost };
	$num = $article->{ $tid };
	$f   = "$ml_home_dir/spool/$num";

	if (-f $f) {
	    my $how_bad = 0;
	    if ($cost =~ /(\w+)\-(\d+)/) { 
		$how_bad += $2;
		$how_bad += 1 if $1 =~ /open/;
		$how_bad  = "!" x ($how_bad > 6 ? 6 : $how_bad);
	    }

	    printf "\n%6s  %-10s  %s\n", $how_bad, $tid;
	    print _summary($f);
	}
    }
}


sub _summary
{
    my ($f) = @_;
    use FileHandle;
    
    my $buf;
    my $subject;
    my $padding = '      > ';
    my $line = 5;
    my $fh = new FileHandle $f;
    my $zform_is_found = 0;
    if (defined $fh) {
	while (<$fh>) {
	    if (1 ../^$/) {
		if (/^(Subject:.*)=\?ISO\S+B\?(\S+)=\?=/) { 
		    my ($x, $y) = ($1, $2);
		    $y = decode_base64($y);
		    $buf .= $padding;
		    $buf .= $x. Jcode::convert(\$y, 'euc')."\n";
		    $buf .= $padding."\n";
		}
		elsif (/^(Subject:.*)/) {
		    $buf .= $padding. $_;
		    $buf .= $padding."\n";
		}
		next;
	    }

	    # looks zform ?
	    if (/^DTD:/) {
		$zform_is_found = 1;
		next;
	    }

	    # nuke useless lines
	    next if /^\s*$/;
	    next if /^\>/;
	    next if /^\-/;
	    next if /^[-\w]+:/ && (! $zform_is_found);

	    # pick up effetive the first $line lines
	    if ($line--> 0) {
		$buf .= $padding. $_;
	    }
	    else {
		last;
	    }
	}
    }

    $buf;
}
