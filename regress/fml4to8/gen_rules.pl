#!/usr/bin/env perl
#
# $FML: gen_rules.pl,v 1.3 2004/12/30 04:43:37 fukachan Exp $
#

use strict;
use Carp;

my $debug     = $ENV{'debug'} || 0;
my $var_rules = {};
my $var_count = 0;
my $recursive = 0;
my $ignore_regexp = 'unavailable|not_yet_configurable';

# 1. read RULES.txt
_parse_rule_file(@ARGV);

# 2. show translation rules (perl script).
_preamble();
for my $var_name (sort {$a <=> $b} keys %$var_rules) {
    $recursive = 0;
    _print_translated_rules($var_name, $var_rules->{ $var_name });
}
_trailor();

exit 0;


=head1 INITIALIZATION

=cut


# Descriptions: 
#    Arguments: STR($rule_file)
# Side Effects: update $var_rules HASH_REF.
# Return Value: none
sub _parse_rule_file
{
    my ($rule_file) = @_;

    use FileHandle;
    my $rh = new FileHandle $rule_file;
    if (defined $rh) {
	my $var_name = '';
	my $buf;

      LINE:
	while ($buf = <$rh>) {
	    next LINE if $buf =~ /^\s*$/o;
	    next LINE if $buf =~ /^\#/o;

	    if ($buf =~ /^\.if\s+(\S+)/o) {
		$var_name = sprintf("%s_%s", $var_count++, $1);
		$var_rules->{ $var_name } .= $buf;
		next LINE;
	    }

	    if ($var_name) {
		if ($buf =~ /^\s*\.($ignore_regexp)/o) {
		    if ($debug) {
			print STDERR "var_name = $var_name\n";
			print STDERR "\tignored ($1)\n";
		    }
		    # $var_rules->{ $var_name } = '';
		}
		elsif ($buf =~ /\S+/o) {
		    if ($debug) {
			print STDERR "var_name = $var_name\n";
			print STDERR "\t", $buf, "\n";
		    }
		    $var_rules->{ $var_name } .= $buf;
		}
		else {
		    if ($debug) {
			print STDERR "var_name = $var_name\n";
			print STDERR "\t", $buf, "\n";
		    }
		    $var_rules->{ $var_name } .= $buf;
		}
	    }

	}
	$rh->close();
    }
    else {
	croak("cannot open $rule_file\n");
    }
}


=head1 TRANSLATION OF RULES

=cut


# Descriptions: print out preamble of output of perl script.
#    Arguments: none
# Side Effects: none
# Return Value: none
sub _preamble
{
    use File::Basename;
    my $prog = basename($0);

    print qq{#
# -*- perl -*-
#     *** CAUTION *** 
#     DO NOT EDIT THIS FILE BY HAND!.
#     THIS FILE IS AUTOMATICALLY GENERATED BY $prog.
#
# \$FML\$
#
};

print q!
package FML::Merge::FML4::Rules;


# Descriptions: translate fml4 rule to the corresponding fml8 one.
#    Arguments: OBJ($self)
#               HASH_REF($dispatch) HASH_REF($config) HASH_REF($diff) 
#               STR($key) STR($value)
# Side Effects: none
# Return Value: STR
sub translate
{
    my ($self, $dispatch, $config, $diff, $key, $value) = @_;
    my $fp_rule_convert             = $dispatch->{ rule_convert };
    my $fp_rule_prefer_fml4_value   = $dispatch->{ rule_prefer_fml4_value };
    my $fp_rule_prefer_fml8_value   = $dispatch->{ rule_prefer_fml8_value };
    my $fp_rule_ignore              = $dispatch->{ rule_ignore };
    my $fp_rule_not_yet_implemented = $dispatch->{ rule_not_yet_implemented };
    my $s;

!;
}


# Descriptions: print out the trailor part of output of perl script.
#    Arguments: none
# Side Effects: none
# Return Value: none
sub _trailor
{
    print "\n   return '';\n";
    print "} # sub translate\n";
    print "\n1;\n";
}


# Descriptions: print out translated rules.
#    Arguments: STR($var_name) STR($var_rules)
# Side Effects: none
# Return Value: none
sub _print_translated_rules
{
    my ($var_name, $var_rules) = @_;
    my $rule_out = '';
    my $found    = 0;
    my $i        = 0;

    print STDERR "ALLOC $var_name => $var_rules\n" if $debug;
    return unless $var_name;
    return unless $var_rules;

  RULE:
    for my $rule (split(/\n/, $var_rules)) {
	$i++;
	print STDERR "$var_name [$i] $rule\n" if $debug;

	# 1st level (/^.if .../ statement)
	if ($rule =~ /^\.if/o) {
	    $rule_out .= _puts(_parse_if($rule, $recursive));
	}
	elsif ($rule =~ /^\S+/) {
	    print STDERR "UNKNOWN RULE: <$rule>\n";
	}
	# 2nd level (/^\s+\S+/ statement)
	else {
	    $rule =~ s/^\s*//;
	    $rule =~ s/\s*$//;

	    if ($rule =~ /^\.if/o) {
		$recursive++;
		$rule_out .= _puts(_parse_if($rule, $recursive));
		next RULE;
	    }

	    if ($rule eq '.use_fml4_value') {
		$found = 1;
		$rule_out .= _puts("\$s .= \&\$fp_rule_prefer_fml4_value(\$self, \$config, \$diff, \$key, \$value);");
	    }
	    elsif ($rule eq '.use_fml8_value') {
		$found = 1;
		$rule_out .= _puts("\$s .= \&\$fp_rule_prefer_fml8_value(\$self, \$config, \$diff, \$key, \$value);");
	    }
	    elsif ($rule eq '.convert') {
		$found = 1;
		$rule_out .= _puts("\$s .= \&\$fp_rule_convert(\$self, \$config, \$diff, \$key, \$value);");
	    }
	    elsif ($rule =~ /^\s*\.(ignore|not_support)/o) {
		$found = 1;
		$rule_out .= _puts("\$s .= \&\$fp_rule_ignore(\$self, \$config, \$diff, \$key, \$value);");
	    }
	    elsif ($rule =~ /^\s*\.(not_yet_implemented)/o) {
		$found = 1;
		$rule_out .= _puts("\$s .= \&\$fp_rule_not_yet_implemented(\$self, \$config, \$diff, \$key, \$value);");
	    }
	    elsif ($rule =~ /^\s*\.($ignore_regexp)/o) {
		$found = 1;
		$rule_out .= _puts("\$s .= \"\# $rule\";");
	    }
	    else {
		$found = 1;
		$rule_out .= _puts("\$s .= \"$rule\";");
	    }

	    while ($recursive > 0) {
		$rule_out .= _puts("}");
		$recursive--;
	    }

	} # if 
    } # for my $rule (...)

    if ($found) {
	$rule_out .= _puts("return \$s if defined \$s;");
	$rule_out .= _puts("}");
	$rule_out .= _puts("");
	print $rule_out;
    }
}


# Descriptions: parse 1st and 2nd level .if statement.
#    Arguments: STR($rule) NUM($recursive)
# Side Effects: none
# Return Value: none
sub _parse_if
{
    my ($rule, $recursive) = @_;
    my $rule_out = '';

    if ($rule =~ /^\.if\s+(\S+)\s+(==|>|>=|<|<=)\s+(\S+)/) {
	$rule_out .= "\n";
	my ($key, $op, $value) = ($1, $2, $3);
	if ($value =~ /^\d+$/o) {
	    $rule_out .= _puts("if (\$key eq '$key' && \$value $op $value) {");
	    $rule_out .= _puts("\$s = undef;");
	}
	else {
	    $rule_out .= _puts("if (\$key eq '$key' && \$value eq '$value') {");
	    $rule_out .= _puts("\$s = undef;");
	}
    }
    elsif ($rule =~ /^\.if\s+(\S+)\s+\!=\s+(\S+)/) {
	$rule_out .= "\n";
	my ($key, $value) = ($1, $2);
	if ($value =~ /^\d+$/o) {
	    $rule_out .= _puts("if (\$key eq '$key' && \$value \!= $value) {");
	    $rule_out .= _puts("\$s = undef;");
	}
	else {
	    $rule_out .= _puts("if (\$key eq '$key' && \$value ne '$value') {");
	    $rule_out .= _puts("\$s = undef;");
	}
    }
    elsif ($rule =~ /^\.if\s+(\S+)\s*$/) {
	$rule_out .= "\n";
	my $key = $1;
	$rule_out .= _puts("if (\$key eq '$key' && defined \$value) {");
	$rule_out .= _puts("\$s = undef;");
    }

    return $rule_out;
}


=head1 UTILITIES

=cut

# Descriptions: printf wrapper to prepend spaces in a line.
#    Arguments: STR($s)
# Side Effects: none
# Return Value: none
sub _puts
{
    my ($s) = @_;
    my $rule_out = "    " x ($recursive + 1);
    return sprintf("%s%s\n", $rule_out, $s);
}
