<!--
	$FML: bootloader.sgml,v 1.6 2002/04/01 23:41:03 fukachan Exp $
-->

<chapter id="bootloader">
	<title>
	バージョン依存性を解決するための fml ブートローダ
	</title>

<para>

&fmldevel; にはインストールされている fml のバージョン依存性を考慮するた
めに、実行時には本章で述べるようなブートストラップの過程があります。

<screen>
boot していくイメージ

libexec/loader ->
     FML::Process::Switch ->
         FML::Process::Flow ->
              FML::Process::それぞれのプログラムのモジュール
</screen>
</para>


<sect1>
   <title> 例: 配送の場合 </title>

<para>
loader から次々と呼ばれていく様子は、例えば配送処理の場合、次のよう
になります。
</para>

<para>
libexec/loader は /usr/local/etc/fml/main.cf を読みこみます。
fml_version 変数から使うべきライブラリのバージョンを決めます。
例えば fml_vesrion が current-20010501 となっていたら
/usr/local/lib/fml/current-20010501/ 以下にあるライブラリを使うといった
具合です。
</para>

<para>
@INC を設定した後、
loader は FML::Process::Switch をロードし、
$0 を調べます。
その名前から自分の仕事は配送処理だと知ります。
配送処理なので
FML::Process::Distribute をロードし、配送処理に移ります。
</para>

<para>
こういった処理は見かけ上
FML::Process::Flow::ProcessStart() という関数が制御しています。
ProcessStart() が引数として
FML::Process::Distribute を渡され、
FML::Process::Distribute を実行していくという流れになります。
</para>

</sect1>


<sect1>
  <title> FML::Process:: クラスの階層構造 </title>

<para>
<screen>
FML::Process::Distribute >-|
FML::Process::Command    >-|-- FML::Process::Kernel
FML::Process::Mead       >-|    |
                                |-use-a FML::Parse
                                |-use-a FML::Config
                                |-use-a FML::Log
                                |-use-a  ... その他 ...
</screen>

</para>
</sect1>


<sect1>
	<title>
	プロセス実行時に使われるモジュール群
	</title>

<itemizedlist>

   <listitem>
	<para>
	 libexec/loader (wrapper)
	Bootstrap() を実行する。
	fml.pl などはこの loader へのシンボリックリンクです。
	/usr/local/libexec/fml/ を参照して下さい。
	</para>
   </listitem>

   <listitem>
   <itemizedlist>
	<listitem>
	<para>
	   /usr/local/etc/fml/main.cf を読み込む。
		読み込むと fml のバージョンが分かる。
		default_config.cf はバージョン依存であるので、
		ここでまずバージョンを評価しなければいけないことに注意。
	</para>
	</listitem>

	<listitem>
	<para>
	 	( fml.pl を例にとると)
		@ARGV を評価し、
		どのＭＬの config.cf 群をロードすればいいのかを準備する。
		変数の評価と展開には libexec/Standalone.pm を用います。

		これはあまりよくないような気がします。
		libexec/ を @INC に加えないといけないこと、
		libexec/loader と libexec/Standalone.pm の２つが
		入れ換えないといけないものになってしまうので。
	</para>
	</listitem>

	<listitem>
	<para>
		次に
		FML::Process::Switch
		( バージョン依存 )ファイルを
		ロードします。
	</para>

	   <itemizedlist>
		<listitem>
		<para>
		Bootstrap2() および ProcessSwitch() を実行し、
		配送用、コマンドモード用などの各
		プログラム/プロセスなどへ制御を移します(分岐する)。
		この時は $0 から自分の名前を知り、
		どのプロセスへ分岐すればいいのかを判断しています。
		</para>
		</listitem>

		<listitem>
		<para>
		(ポリモーフィズムの例)
		モジュールをダイナミックバインディングし、
		該当するプロセスオブジェクトを生成する。
		そして、プロセスをスタートさせます。

		FML::Process::Flow の中に、
		どのように fml プロセスを実行するかが
		定義されています。
<screen>
$process = new FML::Process::なにか;
$process->prepare($args);
$process->run($args);
$process->finish($args);
</screen>
		のように実行されています。
		各プロセスは、それぞれについて適当な関数を
		用意してください。
		</para>
		</listitem>
	   </itemizedlist>
	</listitem>
   </itemizedlist>
   </listitem>
</itemizedlist>
</sect1>


</chapter>
