<!--
   $FML: config.cf.sgml,v 1.12 2004/04/07 11:07:07 fukachan Exp $
-->


<chapter id="internal.config.cf">
	<title>
	設定ファイル config.cf
	</title>


<!-- ======================================= -->
<sect1 id="config.cf">
	<title>
	ＭＬごとの設定ファイル config.cf
	</title>

<para>
各ＭＬごとにさまざまなカスタマイズをすることができます。
この点は &fml4; でも &fmldevel; でも同様です。
</para>

<para>
そのために &fml4; では各ＭＬのホームディレクトリ $DIR (例:
/var/spool/ml/elena)に config.ph というファイルがあります。これは .ph 
という名前でわかる通り perl script です。
</para>

<para>
&fmldevel; では config.cf 一つです。
フォーマットは postfix や .ini 風の
<screen>
変数 = 値
</screen>
形式になっています。
</para>

<para>
perl module と同様に、=cut の後には perl script を書くようになっていま
す。「キーワード = 値」形式の記述は =cut の前に書いて下さい。
</para>

<sect2>
	<title>
	&fml4; の諸問題
	</title>

<para>
&fml4; の perl script 方式にはいくつか問題があります。
例えば perl script なので、perl が許す限りの自由な書き方ができます。
これは人間にとっては嬉しいのですが、
機械処理の観点からは問題です。というのは 
makefml や CGI をはじめとする設定インターフェイスを書きにくいのです。
そこで &fml4; では、
cf というファイルと config.ph という
2 つのフォーマットの異なるファイルが使われています。
<footnote>
<para>
.mc から .cf を作る点で、なんとなく sendmail みたいですね;)
</para>
</footnote>
</para>

<para>
しかし、これはこれで２つのファイルに分かれてしまう点が
保守しにくさを生みます。
よって &fmldevel; では、
設定インターフェイスにやさしい新フォーマットを提唱します。
それが config.cf です。
これは本質的に postfix 風のフォーマットです。
</para>

</sect2>
</sect1>


<!-- ======================================= -->
<sect1 id="config.cf.format">
	<title>
	config.cf のフォーマット
	</title>

<para>
config.cf のフォーマットは
	<link linkend="main.cf">
	/usr/local/etc/fml/main.cf
	</link>
と同様です。
<screen>
変数名 = 値

変数名 = 値1 値2 値3

変数名 = 値1
         値2
         値3
</screen>
のようにスペースないしは改行で区切って複数の値を書くことができます。
</para>

<para>
変数定義内での $ による変数の展開も可能です。
例えば
<screen>
a = 値1
b = $a/値2
</screen>
は最終的に
<screen>
a = 値1
b = 値1/値2
</screen>
と解釈されます。
</para>


<para>
展開は、すべての変数定義を読み込んだ後に行なわれます。
そのため、以下のような定義をすると
<screen>
a = 値1
b = $a/値2/$c
c = 値3
a = 値4
</screen>
次のように
<screen>
b = 値4/値2/値3
</screen>
と解釈されます。
</para>

</sect1>


<!-- ======================================= -->
<sect1 id="config.cf.format.extension">
	<title>
	postfix style のさらなる拡張
	</title>

<para>
<screen>
変数名 += 値
変数名 -= 値
</screen>
で、特定の値の足し引きができます。
</para>

<para>
<screen>
x  = a b c d
x -= b
</screen>
は
<screen>
x = a c d
</screen>
と解釈されます。
</para>

<para>
また
<screen>
x  = a b c d
x += e
</screen>
は
<screen>
x = a b c d e
</screen>
となります。
</para>

</sect1>


<!-- ======================================= -->
<sect1 id="config.cf.overload">
	<title>
	config.cf の多重読み込み(変数定義の上書き)
	</title>

<para>
複数の config.cf を読み込み、定義の上書きを行なうことができます。
</para>

<para>
これを利用して
『デフォルトの定義』、
『サイト固有の定義』、
『ドメイン固有の定義』
などを別のファイルに分離することができます。
デフォルトでは、いくつかの .cf ファイルに分離されています。
</para>

<para>
fml は起動時にそれらのファイルを順番に読みこみ、
最後にＭＬ固有の config.cf を読み込みます。
そして、その後に変数の展開処理を行ないます。
</para>

</sect1>

<!-- ======================================= -->
<sect1>
	<title>
	展開後に変数を代入すると？
	</title>

<para>
$ をふくむ変数の値の代入が行なわれると、
次に値を取り出すメソッド
   <footnote>
   <para>
   perl の tie 操作
   </para>
   </footnote>
が呼ばれた際に、変数の再展開が行なわれます。
</para>

<para>
例えば
<screen>
$config->{ key } = '$ml_home_dir/value';
</screen>
という代入処理が行なわれると、次に
<screen>
$config->{ another_key }
</screen>
(キーはなんでもよい)メソッドが呼ばれた際に再評価されることになります。
</para>


<sect2>
	<title>
	内部構造: 変数展開
	</title>

<para>
内部構造の話をすると、
まず %_fml_config に キーと値 の組が保存されます。
これは $dir/$file のような形式のままです。

get() はこのハッシュではなく %_fml_config_result の値を返しています。
このハッシュ中の値は $dir などが展開された後の値で、
/var/spool/ml/elena/file などとなっています。
この変数の値の展開は get() なりで呼ばれた時に始めて行なわれます。
</para>

</sect2>

</sect1>


<sect1 id="list.variables.by.alphabeticalorder">
	<title>
	変数一覧 (alphabetical order)
	</title>

&var.table.list.variables;

</sect1>


<sect1 id="list.variables.by.class">
	<title>
	変数一覧 (クラス分類)
	</title>

&var.table.class.variables;

</sect1>


</chapter>
