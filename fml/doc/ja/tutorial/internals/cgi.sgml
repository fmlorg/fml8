<!--
   $FML: cgi.sgml,v 1.9 2002/07/23 09:34:34 fukachan Exp $
-->

<chapter id="internalcgi">
	<title>
	CGI プロセスの内部構造
	</title>


<sect1 id="internalcgi.method">
	<title>
	メソッド
	</title>

<para>
FML::CGI のクラスは以下のメソッド群を実装して下さい。
<screen>
html_start()
run_cgi_main()
run_cgi_title()
run_cgi_navigator()
run_cgi_menu()
run_cgi_command_help()
run_cgi_options()
html_end()
</screen>
ここで
html_start() は、
ようするに HTML の先頭部分、たとえば DOCTYPE から BODY あたりを、
html_end() は
/BODY と /HTML を表示する部分をカスタマイズするために用います。
run_◎◎ メソッド群では BODY の部分を定義しています。
</para>

<para>
$curproc の run() メソッドは
<screen>
html_start()
run_cgi_XXX() 群を実行(テーブル状に出力を配置する)
html_end()
</screen>
を順番に実行しています。
つまり CGI プロセスの実行のフロー( FML::Process::Flow 参照)は
<screen>
new()
prepare()
verify_request()
run()
   html_start()
   run_cgi_○○()
   html_end()
finish()
</screen>
ということになります。
</para>

</sect1>


<sect1 id="internalcgi.frames">
	<title>
	CGI の画面の作りとメソッド
	</title>

<para>
fml CGI スクリプトでは典型的な画面が次のように分割されると考えています。
<screen>
          ヘッダ
◎        メニュー    ◎
バー１    メイン      バー２
◎        メニュー    ◎
          フッタ
</screen>
なお、バー１と２の部分は navigation などと呼ばれます。
</para>


<para>
ヘッダ部分( HTTP ヘッダではなく、HTML の DOCTYPE から BODY あたり)
やフッタの部分は
html_start() および html_end() で HTML コードを生成するでしょう。
BODY の中身は真中の３ｘ３のテーブル状の部分で、run_cgi() から呼ばれる
メソッドが生成しています。
</para>


<para>
run_cgi() の中身をもっと細かくすることと、
画面上のどの部分をどのメソッドが記述するのかを指定できる
アクセスメソッドが必要です。
また BODY の中身も、これにあわせて、より細かく
<screen>
nw   north  ne
west center east
sw   south  se
</screen>
という３x３の精度で表現されています。
</para>


<sect2>
	<title>
	現在の CGI の画面の構造	
	</title>

<para>
以下のような３x３のテーブル構造をとっており、
<screen>
run_cgi_main
			run_cgi_title
run_cgi_navigator	run_cgi_menu	run_cgi_command_help
run_cgi_options
</screen>
HTML のレベルでは、TABLE 命令を使って疑似的なナビゲーションバーのよう
なものを作っている。そして、ハッシュテーブルで定義されている関数を決め
られた順番で実行し、テーブルを作成している。
</para>

<para>
run_cgi_main() は何らかの処理をしない限り何も表示しない。
大抵は「なし」か「OK …」程度。エラーメッセージを表示することもある。
また、この関数はＭＬ一覧などをきちんと最新の情報にするために、
画面を描く前に実行する必要がある。
</para>

<para>
ちなみに、run_cgi_main() は個々の関数を呼び出すためのトップレベルのア
ダプター層で、FML::CGI::Menu::Admin に定義されている。個々のコマンドは 
makefml の時と同様にこの関数経由で実行される。
</para>

<para>
ただし、ログやメンバーリスト一覧のように run_cgi_menu() から結果の表示
をしているものもある。これは表示のオプションの指定をさせるために、
run_cgi_main() ではなく run_cgi_menu() 経由で表示しているともいえるの
だが、なにしろコマンドの結果の表示が長いので、今のように menu() 経由の
ほうがよいと思われる。
</para>

</sect2>

</sect1>


<sect1 id="internalcgi.trampoline">
	<title>
	画面とトランポリン機構
	</title>

<para>
CGI の表示部分は
FML::Command::
以下のクラスに移動させます。
しかしながら、
FML::Command::
の中に実体があるとは限らず
object composition の形式で
FML::CGI:: クラスが提供するメニュー生成クラスを
使うことになるでしょう。
たとえば subscribe の場合
<screen>
FML::CGI::Admin::Main →
FML::Command::Admin::subscribe →
FML::CGI::Admin::User →
メニューの表示
</screen>
などとなっていて、Mach のトランポリン機構のように、いったりきたりしま
す。
</para>

</sect1>


<sect1 id="internalcgi.problems">
	<title>
	備考: FML::CGI::Admin:: ではハードコーディングするしかない？	
	</title>

<para>
例えば FML::CGI::Admin::User では
$comname と maps の関係がハードコーディングされてるけれど、
でも、これはしかたないんじゃないかなぁ…
</para>

<para>
config に追い出すと、とてつもなくいっぱい変数が必要になりそうだ。
</para>

</sect1>


</chapter>
