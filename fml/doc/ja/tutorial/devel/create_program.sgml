<!--
   $FML: create_program.sgml,v 1.4 2002/07/02 10:39:31 fukachan Exp $
-->

<chapter id="program.create">
	<title>
	新プログラムの作成
	</title>


<sect1>
	<title>
	プログラムを作る(コマンドライン用)
	</title>

<para>
まず FML::Process:: にモジュールを用意します。
最小構成の見本としては FML::Process::Scheduler 、
最大構成としては FML::Process::Distribute
を参考にすると良いでしょう。
</para>

<para>
用意しなければいけない関数(メソッド)は
FML::Process::Flow::ProcessStart()
を見ると分かります。
FML::Process::Flow::ProcessStart()
がプロセスを駆動しているからです。
2002/07 現在、これらのメソッドが必須です。
<screen>
new()
prepare()
verify_request()
run()
finish()
</screen>
ダミーでもよいので、これらのメソッドを適宜用意しておいて下さい。
各メソッドの具体例は、FML::Process を見て下さい。
メソッドの役割を知るためには最大構成の Distribute が一番適当かも知れません。
</para>

<para>
<screen>
        FML::Process::Kernel
                |       uses-a FML::Process::{Flow,Utils} FML::Parse ...
                |
                A
        FML::Process::○○○
                        uses-a FML::ほえほえ
                        uses-a CPAN モジュール
                        uses-a …
</screen>
</para>

<para>
FML::Process::○○○
を用意したら、
FML::Process::Switch
を編集します。
このモジュールでは、各プログラムごとに
『ロードするモジュール』
『コマンドラインオプション』
『ＭＬ名を必要とするか否か？』
を定義してください。
編集する場所は以下の private method です。
<screen>
sub _module_specific_options
sub _ml_name_is_required
sub _module_we_use
</screen>
</para>

<para>
この 2 つの準備だけで、新しいプログラムの準備は終りですです。
呼びたい名前のファイルを loader と link もしくは symlink することで
実行が可能になります。
例えば、標準のインストールでは、次のようになっています。
<screen>
% ls -l /usr/local/libexec/fml
total 11
-rw-r--r--  1 fml       wheel  4044 Nov 20 00:19 Standalone.pm
lrwxr-xr-x  1 root      wheel     6 Nov 23 22:10 command -> loader
drwxr-xr-x  3 root      wheel   512 Nov 23 22:10 current-20011123
lrwxr-xr-x  1 root      wheel     6 Nov 23 22:10 distribute -> loader
lrwxr-xr-x  1 root      wheel     6 Nov 23 22:10 fml.pl -> loader
lrwxr-xr-x  1 root      wheel     6 Nov 23 22:10 fmlconf -> loader
lrwxr-xr-x  1 root      wheel     6 Nov 23 22:10 fmldoc -> loader
lrwxr-xr-x  1 root      wheel     6 Nov 23 22:10 fmlhtmlify -> loader
lrwxr-xr-x  1 root      wheel     6 Nov 23 22:10 fmlsch -> loader
lrwxr-xr-x  1 root      wheel     6 Nov 23 22:10 fmlsch.cgi -> loader
lrwxr-xr-x  1 root      wheel     6 Nov 23 22:10 fmlserv -> loader
lrwxr-xr-x  1 root      wheel     6 Nov 23 22:10 fmlthread -> loader
lrwxr-xr-x  1 root      wheel     6 Nov 23 22:10 fmlthread.cgi -> loader
-rwxr-xr-x  1 fml       wheel  4358 Nov 23 22:08 loader
lrwxr-xr-x  1 root      wheel     6 Nov 23 22:10 makefml -> loader
lrwxr-xr-x  1 root      wheel     6 Nov 23 22:10 makefml.cgi -> loader
lrwxr-xr-x  1 root      wheel     6 Nov 23 22:10 mead -> loader
</screen>
</para>

</sect1>


<sect1>
	<title>
	プログラムを作る( CGI 用)
	</title>

<para>
CGI のプログラムは
FML::CGI::○○○
というモジュールです。
CGI 系列では次のような、オブジェクトの関係があります。
<screen>
        FML::Process::Kernel
                |
                A
        FML::Process::CGI::Kernel   uses-a CGI
                |
                A
        FML::Process::CGI
                |
                A
        FML::CGI::○○○
</screen>
</para>

<para>
CGI のプログラムの書き方もコマンドラインプログラムと同様です。
名前空間で区別するために CGI スクリプトのモジュールは
FML::Process ではなく FML::CGI に配置されています。
既存の FML::CGI のモジュールを見本にして、
FML::CGI::○○○
を適宜用意して下さい。
</para>


<para>
FML::CGI::○○○ の注意点は、
用意するメソッドが
<screen>
html_start()
html_end()
</screen>
および
<screen>
run_cgi_main()
run_cgi_title()
run_cgi_navigator()
run_cgi_menu()
run_cgi_command_help()
run_cgi_options()
</screen>
になるという点です。
これらの組で一つの画面が構成されています。
</para>

<para>
これらは FML::Process::CGI の中の
verify_request() および run() から呼ばれた先のメソッドとなっています。
</para>

<para>
CGI プロセスは FML::Process::CGI で駆動され、run() メソッドは
<screen>
$curproc->html_start($args);
画面を作るために run_cgi_xxx() メソッド郡を呼び出す。
$curproc->html_end($args);
</screen>
の順に FML::CGI:: 以下のメソッド群を呼び出しています。
</para>

<para>
ちなみに FML::Process::CGI::Kernel 自身は、
2001/11 現在、プロセスは以下のメソッド
	<footnote>
	<para>
	このため、多くの場合
	FML::Process::Kernel
	のメソッドは CGI::Kernel でオーバロードされており、
	直接呼ばれることは稀です。
	</para>
	</footnote>
からなっています。
<screen>
new()
prepare()
verify_request()
run()
finish()
</screen>
特に、これらを編集する必要はないでしょう。
ちなみに FML::CGI:: は run() から呼ばれています。
</para>

</sect1>


</chapter>
