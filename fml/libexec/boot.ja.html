<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
<TITLE>
fml のブートしていく様
</TITLE>
<META http-equiv="Content-Type"
	content="text/html; charset=EUC-JP">
</HEAD>

<BODY BGCOLOR="#E6E6FA">
<!-- ================== body =========================================== -->

<P>fml のブートしていく様について

<UL>
   <LI> libexec/loader (wrapper)
	<BR>
	Bootstrap() を起動する。
   <UL>
	<LI>   /etc/fml/main.cf を読み込む。
		読み込むと fml のバージョンが分かる。
		default_config.cf はバージョン依存であるので、
		ここでまずバージョンを評価しなければいけないことに注意。

	<LI> 	( fml.pl を例にとると)
		@ARGV を評価し、
		どのＭＬの config.cf 群をロードすればいいのかを準備する。

	<LI>	次に
		libexec/fml ( バージョン依存 )ファイルを
		ロードする。そして、
		ProcessSwitch() 内部を実行し、
		配送用、コマンドモード用
		プログラム/プロセスなどへ制御を移す(分岐する)。
	   <UL>
		<LI>
		$0 から自分の名前を知り、
		どのプロセスへ分岐すればいいのかを判断する。

		<LI>(ポリモーフィズム)
		モジュールをダイナミックバインディングし、
		該当するプロセスオブジェクトを生成する。
		そして、プロセスをスタートさせる。

		具体的には
<PRE>
    $process = new FML::Process::なにか;
    $process->prepare($args);
    $process->run($args);
    $process->finish($args);
</PRE>
		などと書く。

	   </UL>
</UL>

<HR>
<P>Standalone.pm

<PRE>
loader (uses) Standalone.pm
   |
  * 動的にライブラリ(バージョン情報を含む)を選択する
    例: /usr/local/lib/fml/5.000/ほえ/ほえ.pm
   |
  fml
  * 動的にクラスをバインディングしつつ、プロセススタートする。
       実際のコードは $process->run() などとなる。


○ クラスの階層構造？

FML::Process::Distribute-|
FML::Process::Command   -|>- FML::Process::Kernel
FML::Process::Mead      -|    |   
                              |->  FML::Parse
                              |->  FML::Config
                              |->  FML::Log
                              |->   ... その他 ...
</PRE>

<!-- =================================================================== -->
</BODY>
</HTML>
