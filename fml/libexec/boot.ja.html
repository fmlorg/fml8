<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
<TITLE>
fml のブートしていく様
</TITLE>
<META http-equiv="Content-Type"
	content="text/html; charset=EUC-JP">
</HEAD>

<BODY BGCOLOR="#E6E6FA">
<!-- ================== body =========================================== -->

<P>fml のブートしていく様について

<UL>
   <LI> libexec/loader (wrapper)
	<BR>
	Bootstrap() を実行する。
   <UL>
	<LI>   /etc/fml/main.cf を読み込む。
		読み込むと fml のバージョンが分かる。
		default_config.cf はバージョン依存であるので、
		ここでまずバージョンを評価しなければいけないことに注意。

	<LI> 	( fml.pl を例にとると)
		@ARGV を評価し、
		どのＭＬの config.cf 群をロードすればいいのかを準備する。
		変数の評価と展開には libexec/Standalone.pm を用います。
		<BR>		 
		これはあまりよくないような気がします。
		libexec/ を @INC に加えないといけないこと、
		libexec/loader と libexec/Standalone.pm の２つが
		入れ換えないといけないものになってしまうので。

	<LI>	次に
		FML::Process::Switch
		( バージョン依存 )ファイルを
		ロードします。
	   <UL>
		<LI>
		Bootstrap2() および ProcessSwitch() を実行し、
		配送用、コマンドモード用などの各
		プログラム/プロセスなどへ制御を移します(分岐する)。
		この時は $0 から自分の名前を知り、
		どのプロセスへ分岐すればいいのかを判断しています。

		<LI>
		(ポリモーフィズムの例)
		モジュールをダイナミックバインディングし、
		該当するプロセスオブジェクトを生成する。
		そして、プロセスをスタートさせます。
		<BR>
		FML::Process::Flow の中に、
		どのように fml プロセスを実行するかが
		定義されています。
<PRE>
    $process = new FML::Process::なにか;
    $process->prepare($args);
    $process->run($args);
    $process->finish($args);
</PRE>
		のように実行されています。
		各プロセスは、それぞれについて適当な関数を
		用意してください。

	   </UL>
</UL>

<HR>
<P>
○ loader から次々と呼ばれていく様子は、例えば配送処理の場合、次のよう
になる。

libexec/loader は FML::Process::Switch をロードし、
FML::Process::Distribute を実行すると決める。

FML::Process::Flow::ProcessStart() は引数として
FML::Process::Distribute を渡され、
FML::Process::Distribute を実行していく。

<P>
○ クラスの階層構造？

<PRE>
FML::Process::Distribute >-|
FML::Process::Command    >-|-- FML::Process::Kernel
FML::Process::Mead       >-|    |   
                                |-use-a FML::Parse
                                |-use-a FML::Config
                                |-use-a FML::Log
                                |-use-a  ... その他 ...
</PRE>

<!-- =================================================================== -->
</BODY>
</HTML>
