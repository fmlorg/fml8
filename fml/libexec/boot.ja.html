<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
<TITLE>
fml のブートしていく様
</TITLE>
<META http-equiv="Content-Type"
	content="text/html; charset=EUC-JP">
</HEAD>

<BODY BGCOLOR="#E6E6FA">
<!-- ================== body =========================================== -->

<P>fml のブートしていく様について

<UL>
   <LI> libexec/loader (wrapper)
	<BR>
	Bootstrap() を実行する。
   <UL>
	<LI>   /etc/fml/main.cf を読み込む。
		読み込むと fml のバージョンが分かる。
		default_config.cf はバージョン依存であるので、
		ここでまずバージョンを評価しなければいけないことに注意。

	<LI> 	( fml.pl を例にとると)
		@ARGV を評価し、
		どのＭＬの config.cf 群をロードすればいいのかを準備する。
		変数の評価と展開には libexec/Standalone.pm を用います。

	<LI>	次に
		FML::Process::Switchn
		( バージョン依存 )ファイルを
		ロードします。
	   <UL>
		<LI>
		Bootstrap2() および ProcessSwitch() を実行し、
		配送用、コマンドモード用などの各
		プログラム/プロセスなどへ制御を移します(分岐する)。
		この時は
		$0 から自分の名前を知り、
		どのプロセスへ分岐すればいいのかを判断しています。

		<LI>
		(ポリモーフィズムの例)
		モジュールをダイナミックバインディングし、
		該当するプロセスオブジェクトを生成する。
		そして、プロセスをスタートさせる。
		<BR>
		FML::Process::Flow でどのように実行するかが
		定義されています。具体的には
<PRE>
    $process = new FML::Process::なにか;
    $process->prepare($args);
    $process->run($args);
    $process->finish($args);
</PRE>
		などと定義されています。
		各プロセスは、それぞれについて適当な関数を
		用意してください。

	   </UL>
</UL>

<HR>
○ クラスの階層構造？

FML::Process::Distribute-|
FML::Process::Command   -|>- FML::Process::Kernel
FML::Process::Mead      -|    |   
                              |->  FML::Parse
                              |->  FML::Config
                              |->  FML::Log
                              |->   ... その他 ...
</PRE>

<!-- =================================================================== -->
</BODY>
</HTML>
